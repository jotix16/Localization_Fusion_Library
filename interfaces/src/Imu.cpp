////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                        //
//         This program is the confidential and proprietary product of IAV GmbH.          //
// Any unauthorised use, reproduction or transfer of this program is strictly prohibited. //
//                                  Copyright IAV GmbH.                                   //
//             (Subject to limited distribution and restricted disclosure only.)          //
//                                   All rights reserved.                                 //
//                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                        //
// This file is generated by IDLCodeGenPy 1.11.1                                          //
//                                                                                        //
// Please do not modify this file by hand!                                                //
//                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////


#include "geometry_msgs/msg/Quaternion.h"
#include "geometry_msgs/msg/Vector3.h"
#include "std_msgs/msg/Header.h"
#include "sensor_msgs/msg/Imu.h"


namespace sensor_msgs
{
namespace msg
{

std::size_t Imu::serialize(void *pOutput) const
{
    if (!pOutput)
        return 0;
    uint8_t *buf = (uint8_t*)pOutput;

    buf += header.serialize(buf); // Header
    buf += orientation.serialize(buf); // Quaternion
    *(sensor_msgs__Imu__double_array_9*)buf = orientation_covariance;
    //buf += None;
    buf += angular_velocity.serialize(buf); // Vector3
    *(sensor_msgs__Imu__double_array_9*)buf = angular_velocity_covariance;
   /* buf += None;*/
    buf += linear_acceleration.serialize(buf); // Vector3
    *(sensor_msgs__Imu__double_array_9*)buf = linear_acceleration_covariance;
    //buf += None;

    return static_cast<std::size_t>(buf - (uint8_t*)pOutput);
}

std::size_t Imu::deserialize(const void *pInput)
{
    if (!pInput)
        return 0;

    const uint8_t *buf = (const uint8_t*)pInput;


    buf += header.deserialize(buf); // Simple member header: Header
    buf += orientation.deserialize(buf); // Simple member orientation: Quaternion
    orientation_covariance = *reinterpret_cast<const sensor_msgs__Imu__double_array_9*>(buf);
    /*buf += None;*/
    buf += angular_velocity.deserialize(buf); // Simple member angular_velocity: Vector3
    angular_velocity_covariance = *reinterpret_cast<const sensor_msgs__Imu__double_array_9*>(buf);
    //buf += None;
    buf += linear_acceleration.deserialize(buf); // Simple member linear_acceleration: Vector3
    linear_acceleration_covariance = *reinterpret_cast<const sensor_msgs__Imu__double_array_9*>(buf);
  /*  buf += None;*/
    return static_cast<uint32_t>(buf - (uint8_t*)pInput);
}

//! \brief default ctor
Imu::Imu()
{



   /* orientation_covariance = 0;

    angular_velocity_covariance = 0;

    linear_acceleration_covariance = 0;*/
}

//! \brief dtor
Imu::~Imu()
{







}

//! \brief Copy constructor
Imu::Imu(const sensor_msgs::msg::Imu &other)
{

    header = other.header;
    orientation = other.orientation;
    orientation_covariance = other.orientation_covariance;
    angular_velocity = other.angular_velocity;
    angular_velocity_covariance = other.angular_velocity_covariance;
    linear_acceleration = other.linear_acceleration;
    linear_acceleration_covariance = other.linear_acceleration_covariance;}

std::size_t Imu::getSerializedSize() const
{
	std::size_t _size_ = 0;

    _size_ += header.getSerializedSize();
    _size_ += orientation.getSerializedSize();
    //_size_ += None;
    _size_ += angular_velocity.getSerializedSize();
    /*_size_ += None;*/
    _size_ += linear_acceleration.getSerializedSize();
    // _size_ += None;
    return _size_;
}

#ifndef IDL_NO_PTR_ASSIGNMENT_OP
sensor_msgs::msg::Imu& Imu::operator=(const sensor_msgs::msg::Imu &other)
{
    if (this != &other)
    {
        header = other.header;
        orientation = other.orientation;
        orientation_covariance = other.orientation_covariance;
        angular_velocity = other.angular_velocity;
        angular_velocity_covariance = other.angular_velocity_covariance;
        linear_acceleration = other.linear_acceleration;
        linear_acceleration_covariance = other.linear_acceleration_covariance;
    }
    return *this;
}
#endif //IDL_NO_PTR_ASSIGNMENT_OP
} // ns: msg

} // ns: sensor_msgs

